import java.util.*;
import java.util.concurrent.ThreadLocalRandom;


public class ShellSortComparison {

    public enum GapType { SHELL, KNUTH, SEDGEWICK }

    public static void main(String[] args) {
        // Configuration (edit if you want larger experiments)
        int[] sizes = {1000, 5000, 10000, 20000}; // recommended set; adjust with caution
        int repetitions = 5; // repeats per config to average out noise
        GapType[] gapTypes = {GapType.SHELL, GapType.KNUTH, GapType.SEDGEWICK};
        InputType[] inputTypes = {InputType.RANDOM, InputType.SORTED, InputType.REVERSED, InputType.NEARLY_SORTED};

        System.out.println("Shell Sort comparison (Shell, Knuth, Sedgewick) - Timing study");
        System.out.println("Sizes: " + Arrays.toString(sizes) + " | Repetitions: " + repetitions);
        System.out.println();

        // Header for table-like output
        System.out.printf("%-10s %-14s %-8s %-10s %-12s%n",
                "Size", "InputType", "Gap", "Avg(ms)", "StdDev(ms)");
        System.out.println("-----------------------------------------------------------------");

        for (int n : sizes) {
            for (InputType input : inputTypes) {
                for (GapType gapType : gapTypes) {
                    long[] times = new long[repetitions];
                    for (int r = 0; r < repetitions; r++) {
                        int[] arr = generateInput(n, input);
                        long t0 = System.nanoTime();
                        shellSort(arr, gapType);
                        long t1 = System.nanoTime();
                        times[r] = (t1 - t0) / 1_000_000; // ms
                        if (!isSorted(arr)) {
                            System.err.println("SORT CHECK FAILED for n=" + n + " input=" + input + " gap=" + gapType);
                            return;
                        }
                    }
                    double avg = average(times);
                    double sd = stddev(times, avg);
                    System.out.printf("%-10d %-14s %-8s %-10.3f %-12.3f%n",
                            n, input.name(), gapType.name(), avg, sd);
                }
            }
            System.out.println();
        }

        System.out.println("Done. To generate CSV or more detailed logs, modify this class's printouts.");
    }

  
    /**
     * Performs in-place Shell Sort using the specified gap sequence.
     */
    public static void shellSort(int[] arr, GapType gapType) {
        int n = arr.length;
        int[] gaps = createGaps(n, gapType);
        // gaps should be in descending order
        for (int gap : gaps) {
            // insertion sort with stride gap
            for (int i = gap; i < n; i++) {
                int temp = arr[i];
                int j = i;
                while (j >= gap && arr[j - gap] > temp) {
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                arr[j] = temp;
            }
        }
    }

    /**
     * Creates array of gaps (descending) for chosen sequence.
     */
    public static int[] createGaps(int n, GapType gapType) {
        switch (gapType) {
            case KNUTH:
                return knuthGaps(n);
            case SEDGEWICK:
                return sedgewickGaps(n);
            case SHELL:
            default:
                return shellGaps(n);
        }
    }

    // Shell's original sequence: n/2, n/4, ...
    private static int[] shellGaps(int n) {
        ArrayList<Integer> list = new ArrayList<>();
        int gap = n / 2;
        while (gap > 0) {
            list.add(gap);
            gap /= 2;
        }
        return toIntArrayDescending(list);
    }

    // Knuth sequence: h = (3^k - 1) / 2; generate <= n/2
    private static int[] knuthGaps(int n) {
        ArrayList<Integer> list = new ArrayList<>();
        long h = 1;
        while (h < n) {
            list.add((int) h);
            h = 3 * h + 1; // generate increasing sequence 1,4,13,40...
        }
        return toIntArrayDescending(list);
    }

    // Sedgewick sequence (one of his sequences): combination of powers
    // We'll generate Sedgewick's 1986-like sequence: 1, 5, 19, 41, 109, ...
    private static int[] sedgewickGaps(int n) {
        ArrayList<Integer> list = new ArrayList<>();
        int k = 0;
        while (true) {
            long gap;
            if (k % 2 == 0) {
                int m = k / 2;
                gap = (long) (9 * (Math.pow(4, m) - Math.pow(2, m)) + 1);
            } else {
                int m = (k - 1) / 2;
                gap = (long) (Math.pow(4, m + 1) - 3 * Math.pow(2, m + 1) + 1);
            }
            if (gap >= n) break;
            if (gap > 0) list.add((int) gap);
            k++;
            if (k > 40) break; // safety
        }
        if (list.isEmpty()) list.add(1);
        return toIntArrayDescending(list);
    }

    private static int[] toIntArrayDescending(ArrayList<Integer> list) {
        // convert to array and sort descending, because we want largest gap first
        Integer[] arr = list.toArray(new Integer[0]);
        Arrays.sort(arr, Collections.reverseOrder());
        int[] out = new int[arr.length];
        for (int i = 0; i < arr.length; i++) out[i] = arr[i];
        return out;
    }

    // ---------- Input generation ----------

    public enum InputType { RANDOM, SORTED, REVERSED, NEARLY_SORTED }

    private static int[] generateInput(int n, InputType type) {
        int[] arr = new int[n];
        switch (type) {
            case RANDOM:
                ThreadLocalRandom rnd = ThreadLocalRandom.current();
                for (int i = 0; i < n; i++) arr[i] = rnd.nextInt();
                break;
            case SORTED:
                for (int i = 0; i < n; i++) arr[i] = i;
                break;
            case REVERSED:
                for (int i = 0; i < n; i++) arr[i] = n - i;
                break;
            case NEARLY_SORTED:
                for (int i = 0; i < n; i++) arr[i] = i;
                // perform a few swaps
                ThreadLocalRandom r = ThreadLocalRandom.current();
                int swaps = Math.max(1, n / 100); // 1% random swaps
                for (int s = 0; s < swaps; s++) {
                    int a = r.nextInt(n);
                    int b = r.nextInt(n);
                    int tmp = arr[a];
                    arr[a] = arr[b];
                    arr[b] = tmp;
                }
                break;
            default:
                throw new IllegalArgumentException("Unknown input type");
        }
        return arr;
    }

    // ---------- Utilities ----------

    private static boolean isSorted(int[] arr) {
        for (int i = 1; i < arr.length; i++) if (arr[i - 1] > arr[i]) return false;
        return true;
    }

    private static double average(long[] times) {
        long sum = 0;
        for (long t : times) sum += t;
        return (double) sum / times.length;
    }

    private static double stddev(long[] times, double mean) {
        double sumsq = 0;
        for (long t : times) sumsq += (t - mean) * (t - mean);
        return Math.sqrt(sumsq / times.length);
    }
}
